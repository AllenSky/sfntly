#summary Notes & comments about how sfntly works
#labels Phase-Implementation

= Introduction =

This document will as the C++ port matures serve as a log to how different parts of the library work. As of today, there is some general info but mostly CMap specific details.
----
= Font Data Tables =
== `CMapTable` ==
_CMap_ = character map; it converts _code points_ in a _code page_ to _glyph IDs_.

The CMapTable is a table of CMaps (CMaps are also tables; one for every encoding supported by the font). Representing an encoding-dependent character map is in one of 14 formats, out of which formats 0 and 4 are the most used; sfntly/C++ will initially only support formats 0, 2, 4 and 12.

The `CMapTable` is the main class and the container for all other CMap related classes.
----

= Table Building Pipeline =

Building a data table in sfntly is done by the `FontDataTable::Builder::build` method which defines the general pipeline and leaves the details to each implementing subclass (`CMapTable::Builder` for example). Note: *`sub*`* methods are table specific
  # *`ReadableFontDataPtr data = internalReadData()`*
    There are 2 private fields in the `FontDataTable::Builder` class: `rData` and `wData` for `ReadableFontData` and `WritableFontData`. This function returns `rData` if there is any or `wData` (it is cast to readable font data) if `rData` is null.
    _They hold the same data!_
  # *`if (model_changed_)`*
    A font is essentially a binary blob when loaded inside a `FontData` object. A _model_ is the Java/C++ collection of objects that represent the same data in a manipulable format. If you ask for the model (even if you don't write to it), it will count as changed and the underlying raw data will get updated.
  # *`if (!subReadyToSerialize())`*
    * *`return NULL`*
    * `else` 
      # *`size = subDataToSerialize()`*
        The data to be serialized needs to be estimated (the size may be 0, indicating unknown data size) or a negative number indicating an estimate. A positive value means that the exact amount of bytes required to store serialize the table is known.
      # *`WritableDataPtr new_data = container_->getNewData(size)`* 
        A table container is a mechanism used for implementing callbacks to the object that owns the table to be built. This can be *either the font object or another table*. `getNewData` instructs the containing object to allocate more memory to hold the new data (`typeof container_ = FontDataTableBuilderContainer`).
      # *`subSerialize(new_data)`*
        The objects are serialized and written to `new_data`.
      # *`data = new_data`*
  # *`FontDataTablePtr table = subBuildTable(data)`*
    The table is actually built, where `subBuildTable` is overridden by every class of table but a table header is always added. 

== Subtable Builders ==
=== Subtables are lazily built ===

When creating the object view of the font and dealing with lots of tables, it would be wasteful to create builders for every subtable there is since most users only do fairly high level manipulation of the font.
Instead, *only the tables at font level are fully built*. 

All other subtables have builders that contain valid FontData but the object view is not created by default. For the `CMapTable`, this means that if you donâ€™t go through the `getCMapBuilders()` method, the CMap builders are not initialized. So, the builder map would seem to be empty when calling its `size()` method but there are CMaps in the font when calling `numCMaps(internalReadFont())`.
----

== Character encoders ==
Sfntly/Java uses a native ICU-based API for encoding characters. Sfntly/C++ uses ICU directly. In unit tests we assume text is encoded in UTF16. Public APIs will use ICU classes like `UnicodeString`.
