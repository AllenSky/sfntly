=Usage of smart pointers in sfntly C++ port=

In sfntly C++ port, an object ref-counting and smart pointer mechanism is implemented.  The implementation works very like COM.

Ref-countable object type inherits from RefCounted<>, which have addRef() and release() just like IUnknown in COM (but no QueryInterface).  Ptr<> is a smart pointer class like CComPtr<> which is used to hold the ref-countable objects so that the object ref count is handled correctly.

Let's take a look at the example:

{{{
class Foo : public RefCounted<Foo> {
 public:
  static Foo* CreateInstance() {
    Ptr<Foo> obj = new Foo();  // ref count = 1
    return obj.detach();  // Giving away the control of this instance.
  }
};
typedef Ptr<Foo> FooPtr;  // Common short-hand notation.

FooPtr obj;
obj.attach(Foo::CreateInstance());  // ref count = 1
                                    // Take over control but not bumping
                                    // ref count.
{
  FooPtr obj2 = obj;  // ref count = 2
                      // Assignment bumps up ref count.
}  // ref count = 1
   // obj2 out of scope, decrements ref count

obj.release();  // ref count = 0, object destroyed
}}}

Notes on usage:
  * Virtual inherit from RefCount interface in base class if smart pointers are going to be defined.

  * All RefCounted objects must be instantiated on the heap.  Allocating the object on stack will cause crash.

  * Be careful when you have complex inheritance.  For example,
{{{
class A : public RefCounted<A>;
class B : public A, public RefCounted<B>;
}}}
  In this case the smart pointer is pretty dumb and don't count on it to    nicely destroy your objects as designed. Try refactor your code like 
{{{
class I;  // the common interface and implementations
class A : public I, public RefCounted<A>;  // A specific implementation
class B : public I, public RefCounted<B>;  // B specific implementation
}}}

  * Smart pointers here are very bad candidates for function parameters and return values.  Use dumb pointers when passing over the stack.

  * When down_cast is performed on a dangling pointer due to bugs in code, VC++ will generate SEH which is not handled well in VC++ debugger.  One can use WinDBG to run it and get the faulting stack.

  * Idioms for heap object as return value
{{{
Foo* createFoo() { FooPtr obj = new Foo(); return obj.detach(); }
Foo* passthru() { FooPtr obj = createFoo(), return obj; }
FooPtr end_scope_pointer;
end_scope_pointer.attach(passThrough);
}}}

  If you are not passing that object back, you are the end of scope.                